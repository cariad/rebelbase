{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RebelBase RebelBase is a Python package for working with numbers of any base. What does RebelBase do? Want to work with base 3 numbers? We've got you covered. from rebelbase import Base3 n = Base3 ( 42 ) # Represent decimal 42 in base 3 print ( \"n: \" , n ) # \"1120\" (Decimal 42 == base 3 1120) print ( \"n + 1:\" , n + 1 ) # \"1121\" (Decimal 42 + 1 == base 3 1121) print ( \"n - 1:\" , n - 1 ) # \"1112\" (Decimal 42 - 1 == base 3 1112) print ( \"n / 2:\" , n / 2 ) # \"210\" (Decimal 42 / 2 == base 3 210) print ( \"n * 2:\" , n * 2 ) # \"10010\" (Decimal 42 * 1 == base 3 10010) n = Base3 ( \"212\" ) # Create the base 3 value 212 print ( int ( n )) # \"23\" (Base 3 212 == decimal 23) Need to make your own bonkers base 5 system with vowels for digits? No problem. from rebelbase.number import Number class Base5 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"A\" , \"E\" , \"I\" , \"O\" , \"U\" ) n = Base5 ( 42 ) # Represent decimal 42 in base 5 print ( \"n: \" , n ) # \"EOI\" (Decimal 42 == base 5 EOI) print ( \"n + 1:\" , n + 1 ) # \"EOO\" (Decimal 42 + 1 == base 5 EOO) print ( \"n - 1:\" , n - 1 ) # \"EOE\" (Decimal 42 - 1 == base 5 EOE) print ( \"n / 2:\" , n / 2 ) # \"UE\" (Decimal 42 / 2 == base 5 UE) print ( \"n * 2:\" , n * 2 ) # \"OEU\" (Decimal 42 * 2 == base 5 OEU) n = Base5 ( \"OOO\" ) # Create the base 5 value OOO print ( int ( n )) # \"93\" (Base 5 OOO == decimal 93) A Number can be created with optional zero support for any base. Numbers can be initialised with their decimal value or string representation. A ton of Python operations -- including addition, subtraction, floor and true division, multiplication, modulo and exponentiation -- work out of the box. Installation RebelBase requires Python 3.9 or later. pip install rebelbase Support Please raise bugs, request new features and ask questions at github.com/cariad/rebelbase/issues . Contributions See CONTRIBUTING.md for contribution guidelines. The Project RebelBase is \u00a9 2022 Cariad Eccleston and released under the MIT License at cariad/rebelbase . The Author Hello! \ud83d\udc4b I'm Cariad Eccleston and I'm a freelance backend and infrastructure engineer in the United Kingdom. You can find me at cariad.earth , github.com/cariad , linkedin.com/in/cariad and on Mastodon at @cariad@tech.lgbt .","title":"RebelBase"},{"location":"#rebelbase","text":"RebelBase is a Python package for working with numbers of any base.","title":"RebelBase"},{"location":"#what-does-rebelbase-do","text":"Want to work with base 3 numbers? We've got you covered. from rebelbase import Base3 n = Base3 ( 42 ) # Represent decimal 42 in base 3 print ( \"n: \" , n ) # \"1120\" (Decimal 42 == base 3 1120) print ( \"n + 1:\" , n + 1 ) # \"1121\" (Decimal 42 + 1 == base 3 1121) print ( \"n - 1:\" , n - 1 ) # \"1112\" (Decimal 42 - 1 == base 3 1112) print ( \"n / 2:\" , n / 2 ) # \"210\" (Decimal 42 / 2 == base 3 210) print ( \"n * 2:\" , n * 2 ) # \"10010\" (Decimal 42 * 1 == base 3 10010) n = Base3 ( \"212\" ) # Create the base 3 value 212 print ( int ( n )) # \"23\" (Base 3 212 == decimal 23) Need to make your own bonkers base 5 system with vowels for digits? No problem. from rebelbase.number import Number class Base5 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"A\" , \"E\" , \"I\" , \"O\" , \"U\" ) n = Base5 ( 42 ) # Represent decimal 42 in base 5 print ( \"n: \" , n ) # \"EOI\" (Decimal 42 == base 5 EOI) print ( \"n + 1:\" , n + 1 ) # \"EOO\" (Decimal 42 + 1 == base 5 EOO) print ( \"n - 1:\" , n - 1 ) # \"EOE\" (Decimal 42 - 1 == base 5 EOE) print ( \"n / 2:\" , n / 2 ) # \"UE\" (Decimal 42 / 2 == base 5 UE) print ( \"n * 2:\" , n * 2 ) # \"OEU\" (Decimal 42 * 2 == base 5 OEU) n = Base5 ( \"OOO\" ) # Create the base 5 value OOO print ( int ( n )) # \"93\" (Base 5 OOO == decimal 93) A Number can be created with optional zero support for any base. Numbers can be initialised with their decimal value or string representation. A ton of Python operations -- including addition, subtraction, floor and true division, multiplication, modulo and exponentiation -- work out of the box.","title":"What does RebelBase do?"},{"location":"#installation","text":"RebelBase requires Python 3.9 or later. pip install rebelbase","title":"Installation"},{"location":"#support","text":"Please raise bugs, request new features and ask questions at github.com/cariad/rebelbase/issues .","title":"Support"},{"location":"#contributions","text":"See CONTRIBUTING.md for contribution guidelines.","title":"Contributions"},{"location":"#the-project","text":"RebelBase is \u00a9 2022 Cariad Eccleston and released under the MIT License at cariad/rebelbase .","title":"The Project"},{"location":"#the-author","text":"Hello! \ud83d\udc4b I'm Cariad Eccleston and I'm a freelance backend and infrastructure engineer in the United Kingdom. You can find me at cariad.earth , github.com/cariad , linkedin.com/in/cariad and on Mastodon at @cariad@tech.lgbt .","title":"The Author"},{"location":"bases/","text":"Baked-in bases The Base2 class wraps and extends the Number class to represent base 2 numbers. The Base3 class wraps and extends the Number class to represent base 3 numbers. The Base26C class wraps and extends the Number class to represent a base 26 number with continuous, non-zero representation. See optional zero support for more information about why you might want this.","title":"Baked-in bases"},{"location":"bases/#baked-in-bases","text":"The Base2 class wraps and extends the Number class to represent base 2 numbers. The Base3 class wraps and extends the Number class to represent base 3 numbers. The Base26C class wraps and extends the Number class to represent a base 26 number with continuous, non-zero representation. See optional zero support for more information about why you might want this.","title":"Baked-in bases"},{"location":"create/","text":"Creating a new base A basic base To create a new numeric base, extend the Number class and implement the abstract digits class method to return the digits of the base in ascending value order. For example, a base 4 system would look something like this: from rebelbase import Number class Base4 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"0\" , \"1\" , \"2\" , \"3\" ) Custom string representation By default, string representations are prefixed with - to indicate negativity and seperate the integral and fractional parts with a . . print ( Base4 ( - 7 )) # \"-13\" (Decimal -7 == base 4 -13) print ( Base4 ( 7.75 )) # \"13.3\" (Decimal 7.75 == base 4 13.3) To customise the string representation, override the to_string and from_string functions. For example, to always include a sign symbol and to separate the fractional digits with a comma instead: from rebelbase import Number , Value class Base4 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"0\" , \"1\" , \"2\" , \"3\" ) @classmethod def from_string ( cls , v : str ) -> Value : if not v : return Value ( cls . base ()) positive = not v [ 0 ] == \"-\" if v [ 0 ] in ( \"+\" , \"-\" ): v = v [ 1 :] dot = v . find ( \",\" ) integral_digits = v [: dot ] if dot > 0 else v integral_bits = [ cls . value_of_digit ( d ) for d in integral_digits ] fractional_digits = v [ dot + 1 :] if dot > 0 else \"\" fractional_bits = [ cls . value_of_digit ( d ) for d in fractional_digits ] return Value ( cls . base (), positive , integral_bits , fractional_bits ) def to_string ( self , v : Value ) -> str : bits = [ \"+\" if v . positive else \"-\" ] if v . integral : bits . extend ([ self . digit_for_value ( x ) for x in v . integral ]) else : bits . append ( self . digit_for_value ( 0 )) if v . fractional : bits . append ( \",\" ) bits . extend ([ self . digit_for_value ( x ) for x in v . fractional ]) return \"\" . join ( bits ) print ( Base4 ( - 7 )) # \"-13\" (Decimal -7 == base 4 -13) print ( Base4 ( 7.75 )) # \"+13,3\" (Decimal 7.75 == base 4 +13,3) print ( int ( Base4 ( \"+11\" ))) # \"5\" (Base 4 +11 == decimal 5) print ( float ( Base4 ( \"+3,12\" ))) # \"3.375\" (Base 4 +3,12 == decimal 3.375) The Value class describes a number by its: Base as an integer decimal. Sign; True indicates a positive value. Tuple of integral digit values from most- to least-significant. For example, an integral value represented by 1023 would be recorded as (1, 0, 2, 3) . Tuple of fractional digit values from most- to least-significant. For example, a fractional value represented by 7012 would be recorded as (7, 0, 1, 2) . The value_of_digit() function returns the integer bit value of the passed digit. Respectively, digit_for_value() returns the digit for any passed integer bit value. Numeric bases without zero If your base won't support zero then override supports_zero to return False and don't return a zero digit from digits . from rebelbase import Number class Base4 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"1\" , \"2\" , \"3\" ) @classmethod def supports_zero ( cls ) -> bool : return False See optional zero support for more information about why you might want to do this.","title":"Creating a new base"},{"location":"create/#creating-a-new-base","text":"","title":"Creating a new base"},{"location":"create/#a-basic-base","text":"To create a new numeric base, extend the Number class and implement the abstract digits class method to return the digits of the base in ascending value order. For example, a base 4 system would look something like this: from rebelbase import Number class Base4 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"0\" , \"1\" , \"2\" , \"3\" )","title":"A basic base"},{"location":"create/#custom-string-representation","text":"By default, string representations are prefixed with - to indicate negativity and seperate the integral and fractional parts with a . . print ( Base4 ( - 7 )) # \"-13\" (Decimal -7 == base 4 -13) print ( Base4 ( 7.75 )) # \"13.3\" (Decimal 7.75 == base 4 13.3) To customise the string representation, override the to_string and from_string functions. For example, to always include a sign symbol and to separate the fractional digits with a comma instead: from rebelbase import Number , Value class Base4 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"0\" , \"1\" , \"2\" , \"3\" ) @classmethod def from_string ( cls , v : str ) -> Value : if not v : return Value ( cls . base ()) positive = not v [ 0 ] == \"-\" if v [ 0 ] in ( \"+\" , \"-\" ): v = v [ 1 :] dot = v . find ( \",\" ) integral_digits = v [: dot ] if dot > 0 else v integral_bits = [ cls . value_of_digit ( d ) for d in integral_digits ] fractional_digits = v [ dot + 1 :] if dot > 0 else \"\" fractional_bits = [ cls . value_of_digit ( d ) for d in fractional_digits ] return Value ( cls . base (), positive , integral_bits , fractional_bits ) def to_string ( self , v : Value ) -> str : bits = [ \"+\" if v . positive else \"-\" ] if v . integral : bits . extend ([ self . digit_for_value ( x ) for x in v . integral ]) else : bits . append ( self . digit_for_value ( 0 )) if v . fractional : bits . append ( \",\" ) bits . extend ([ self . digit_for_value ( x ) for x in v . fractional ]) return \"\" . join ( bits ) print ( Base4 ( - 7 )) # \"-13\" (Decimal -7 == base 4 -13) print ( Base4 ( 7.75 )) # \"+13,3\" (Decimal 7.75 == base 4 +13,3) print ( int ( Base4 ( \"+11\" ))) # \"5\" (Base 4 +11 == decimal 5) print ( float ( Base4 ( \"+3,12\" ))) # \"3.375\" (Base 4 +3,12 == decimal 3.375) The Value class describes a number by its: Base as an integer decimal. Sign; True indicates a positive value. Tuple of integral digit values from most- to least-significant. For example, an integral value represented by 1023 would be recorded as (1, 0, 2, 3) . Tuple of fractional digit values from most- to least-significant. For example, a fractional value represented by 7012 would be recorded as (7, 0, 1, 2) . The value_of_digit() function returns the integer bit value of the passed digit. Respectively, digit_for_value() returns the digit for any passed integer bit value.","title":"Custom string representation"},{"location":"create/#numeric-bases-without-zero","text":"If your base won't support zero then override supports_zero to return False and don't return a zero digit from digits . from rebelbase import Number class Base4 ( Number ): @classmethod def digits ( cls ) -> tuple [ str , ... ]: return ( \"1\" , \"2\" , \"3\" ) @classmethod def supports_zero ( cls ) -> bool : return False See optional zero support for more information about why you might want to do this.","title":"Numeric bases without zero"},{"location":"number/","text":"Number class The Number class is the base for all numbers. All of the provided numeric classes wrap and extend this class. Construction To construct a Number , either: Pass in the decimal value as a float or integer: from rebelbase import Base2 n = Base2 ( 22 ) print ( n ) # \"10110\" (Decimal 22 == base 2 10110) Pass in the string representation of the number in its base form: from rebelbase import Base2 n = Base2 ( \"10110\" ) print ( int ( n )) # \"22\" (Base 2 10110 == decimal 22) String representation Cast a Number to a string to get a representation of its base value. For example, to cast a base 2 number to a series of 0 and 1 : from rebelbase import Base2 print ( Base2 ( 12 )) # \"1100\" (Decimal 12 == base 2 1100) Functions .base() gets the base of the number. For example, 10 to indicate a base 10 number. .digits() gets a tuple of the digits that make up the number's numeric system in ascending value order. .from_string() converts a string to internal value representation. .name() gets the name of the number's numeric system. .parse() attempts to parse any given object into a float or integer value. .supports_zero() indicates whether or not the number supports zero. See optional zero support for more information about why zero might be unsupported. .to_string() converts internal value representation to a string. Properties .value gets the decimal value as a float or int. This value can also be read by passing the Number into float() or int() . .values gets the internal representation of the value. Math operations Absolute value Given a positive or negative Number n , abs(n) returns a Number of the positive value of n . from rebelbase import Base2 n = Base2 ( - 17 ) print ( abs ( n )) # \"10001\" (Decimal 17 == base 2 10001) Addition Adding a float, integer, string or Number to a Number will return a new Number with the summed value, even if the bases are different: from rebelbase import Base2 , Base3 a = Base2 ( 2 ) print ( a + Base2 ( 3 )) # \"101\" (Base 2 10 + base 2 11 == base 2 101) print ( a + Base3 ( \"10\" )) # \"101\" (Base 2 10 + base 3 10 == base 2 101) print ( a + \"11\" ) # \"101\" (Base 2 10 + base 2 11 == base 2 101) print ( a + 3 ) # \"101\" (Base 2 10 + decimal 3 == base 2 101) Conversion to float Given a Number n , float(n) returns a Number of the float value of n . from rebelbase import Base2 n = Base2 ( 3 ) print ( float ( n )) # \"3.0\" Conversion to integer Given a Number n , int(n) returns a Number of the int value of n . from rebelbase import Base2 n = Base2 ( 3.4 ) print ( int ( n )) # 3 Equality A Number is considered equal to a float, integer, string or another Number if the represented value is the same, even if the bases are different: from rebelbase import Base2 , Base3 a = Base2 ( 2 ) print ( a == Base2 ( 2 )) # \"True\" (Base 2 10 == base 2 10) print ( a == Base3 ( \"2\" )) # \"True\" (Base 2 10 == base 3 2) print ( a == \"10\" ) # \"True\" (Base 2 10 == base 2 10) print ( a == 2 ) # \"True\" (Base 2 10 == decimal 2) Exponentiation Raising a float, integer, string or Number to a power represented by a Number (or vice versa) will return a new Number with the exponentiated value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 8 ) print ( n ** Base2 ( 3 )) # \"1000000000\" (Base 2 1000 ** base 2 11 == base 2 1000000000) print ( n ** Base3 ( \"10\" )) # \"1000000000\" (Base 2 1000 ** base 3 10 == base 2 1000000000) print ( n ** \"11\" ) # \"1000000000\" (Base 2 1000 ** base 2 11 == base 2 1000000000) print ( n ** 3 ) # \"1000000000\" (Base 2 1000 ** decimal 3 == base 2 1000000000) Division Dividing a float, integer, string or Number by a Number (or vice versa) will return a new Number with the divided value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 13.2 ) print ( n / Base2 ( 3 )) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / base 2 11 == base 2 100.01100110011001100) print ( n / Base3 ( \"10\" )) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / base 3 10 == base 2 100.01100110011001100) print ( n / \"11\" ) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / base 2 11 == base 2 100.01100110011001100) print ( n / 3 ) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / decimal 3 == base 2 100.01100110011001100) print ( n // Base2 ( 3 )) # \"100\" (Base 2 1101.00110011001100110 // base 2 11 == base 2 100) print ( n // Base3 ( \"10\" )) # \"100\" (Base 2 1101.00110011001100110 // base 3 10 == base 2 100) print ( n // \"11\" ) # \"100\" (Base 2 1101.00110011001100110 // base 2 11 == base 2 100) print ( n // 3 ) # \"100\" (Base 2 1101.00110011001100110 // decimal 3 == base 2 100) Modulo Reducing a float, integer, string or Number modulo a Number (or vice versa) will return a new Number with the modulus value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 8 ) print ( n % Base2 ( 3 )) # \"10\" (Base 2 1000 % base 2 11 == base 2 10) print ( n % Base3 ( \"10\" )) # \"10\" (Base 2 1000 % base 3 10 == base 2 10) print ( n % \"11\" ) # \"10\" (Base 2 1000 % base 2 11 == base 2 10) print ( n % 3 ) # \"10\" (Base 2 1000 % decimal 3 == base 2 10) Multiplication Multiplying a float, integer, string or Number by a Number (or vice versa) will return a new Number with the multiplied value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 8 ) print ( n * Base2 ( 3 )) # \"11000\" (Base 2 1000 * base 2 11 == base 2 11000) print ( n * Base3 ( \"10\" )) # \"11000\" (Base 2 1000 * base 3 10 == base 2 11000) print ( n * \"11\" ) # \"11000\" (Base 2 1000 * base 2 11 == base 2 11000) print ( n * 3 ) # \"11000\" (Base 2 1000 * decimal 3 == base 2 11000) Subtraction Subtracting a float, integer, string or Number from a Number (or vice versa) will return a new Number with subtracted value, even if the bases are different: from rebelbase import Base2 , Base3 a = Base2 ( 17 ) print ( a - Base2 ( 3 )) # \"1110\" (Base 2 10001 - base 2 11 == base 2 1110) print ( a - Base3 ( \"10\" )) # \"1110\" (Base 2 10001 - base 3 10 == base 2 1110) print ( a - \"11\" ) # \"1110\" (Base 2 10001 - base 2 11 == base 2 1110) print ( a - 3 ) # \"1110\" (Base 2 10001 - decimal 3 == base 2 1110)","title":"Number class"},{"location":"number/#number-class","text":"The Number class is the base for all numbers. All of the provided numeric classes wrap and extend this class.","title":"Number class"},{"location":"number/#construction","text":"To construct a Number , either: Pass in the decimal value as a float or integer: from rebelbase import Base2 n = Base2 ( 22 ) print ( n ) # \"10110\" (Decimal 22 == base 2 10110) Pass in the string representation of the number in its base form: from rebelbase import Base2 n = Base2 ( \"10110\" ) print ( int ( n )) # \"22\" (Base 2 10110 == decimal 22)","title":"Construction"},{"location":"number/#string-representation","text":"Cast a Number to a string to get a representation of its base value. For example, to cast a base 2 number to a series of 0 and 1 : from rebelbase import Base2 print ( Base2 ( 12 )) # \"1100\" (Decimal 12 == base 2 1100)","title":"String representation"},{"location":"number/#functions","text":".base() gets the base of the number. For example, 10 to indicate a base 10 number. .digits() gets a tuple of the digits that make up the number's numeric system in ascending value order. .from_string() converts a string to internal value representation. .name() gets the name of the number's numeric system. .parse() attempts to parse any given object into a float or integer value. .supports_zero() indicates whether or not the number supports zero. See optional zero support for more information about why zero might be unsupported. .to_string() converts internal value representation to a string.","title":"Functions"},{"location":"number/#properties","text":".value gets the decimal value as a float or int. This value can also be read by passing the Number into float() or int() . .values gets the internal representation of the value.","title":"Properties"},{"location":"number/#math-operations","text":"","title":"Math operations"},{"location":"number/#absolute-value","text":"Given a positive or negative Number n , abs(n) returns a Number of the positive value of n . from rebelbase import Base2 n = Base2 ( - 17 ) print ( abs ( n )) # \"10001\" (Decimal 17 == base 2 10001)","title":"Absolute value"},{"location":"number/#addition","text":"Adding a float, integer, string or Number to a Number will return a new Number with the summed value, even if the bases are different: from rebelbase import Base2 , Base3 a = Base2 ( 2 ) print ( a + Base2 ( 3 )) # \"101\" (Base 2 10 + base 2 11 == base 2 101) print ( a + Base3 ( \"10\" )) # \"101\" (Base 2 10 + base 3 10 == base 2 101) print ( a + \"11\" ) # \"101\" (Base 2 10 + base 2 11 == base 2 101) print ( a + 3 ) # \"101\" (Base 2 10 + decimal 3 == base 2 101)","title":"Addition"},{"location":"number/#conversion-to-float","text":"Given a Number n , float(n) returns a Number of the float value of n . from rebelbase import Base2 n = Base2 ( 3 ) print ( float ( n )) # \"3.0\"","title":"Conversion to float"},{"location":"number/#conversion-to-integer","text":"Given a Number n , int(n) returns a Number of the int value of n . from rebelbase import Base2 n = Base2 ( 3.4 ) print ( int ( n )) # 3","title":"Conversion to integer"},{"location":"number/#equality","text":"A Number is considered equal to a float, integer, string or another Number if the represented value is the same, even if the bases are different: from rebelbase import Base2 , Base3 a = Base2 ( 2 ) print ( a == Base2 ( 2 )) # \"True\" (Base 2 10 == base 2 10) print ( a == Base3 ( \"2\" )) # \"True\" (Base 2 10 == base 3 2) print ( a == \"10\" ) # \"True\" (Base 2 10 == base 2 10) print ( a == 2 ) # \"True\" (Base 2 10 == decimal 2)","title":"Equality"},{"location":"number/#exponentiation","text":"Raising a float, integer, string or Number to a power represented by a Number (or vice versa) will return a new Number with the exponentiated value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 8 ) print ( n ** Base2 ( 3 )) # \"1000000000\" (Base 2 1000 ** base 2 11 == base 2 1000000000) print ( n ** Base3 ( \"10\" )) # \"1000000000\" (Base 2 1000 ** base 3 10 == base 2 1000000000) print ( n ** \"11\" ) # \"1000000000\" (Base 2 1000 ** base 2 11 == base 2 1000000000) print ( n ** 3 ) # \"1000000000\" (Base 2 1000 ** decimal 3 == base 2 1000000000)","title":"Exponentiation"},{"location":"number/#division","text":"Dividing a float, integer, string or Number by a Number (or vice versa) will return a new Number with the divided value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 13.2 ) print ( n / Base2 ( 3 )) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / base 2 11 == base 2 100.01100110011001100) print ( n / Base3 ( \"10\" )) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / base 3 10 == base 2 100.01100110011001100) print ( n / \"11\" ) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / base 2 11 == base 2 100.01100110011001100) print ( n / 3 ) # \"100.01100110011001100\" (Base 2 1101.00110011001100110 / decimal 3 == base 2 100.01100110011001100) print ( n // Base2 ( 3 )) # \"100\" (Base 2 1101.00110011001100110 // base 2 11 == base 2 100) print ( n // Base3 ( \"10\" )) # \"100\" (Base 2 1101.00110011001100110 // base 3 10 == base 2 100) print ( n // \"11\" ) # \"100\" (Base 2 1101.00110011001100110 // base 2 11 == base 2 100) print ( n // 3 ) # \"100\" (Base 2 1101.00110011001100110 // decimal 3 == base 2 100)","title":"Division"},{"location":"number/#modulo","text":"Reducing a float, integer, string or Number modulo a Number (or vice versa) will return a new Number with the modulus value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 8 ) print ( n % Base2 ( 3 )) # \"10\" (Base 2 1000 % base 2 11 == base 2 10) print ( n % Base3 ( \"10\" )) # \"10\" (Base 2 1000 % base 3 10 == base 2 10) print ( n % \"11\" ) # \"10\" (Base 2 1000 % base 2 11 == base 2 10) print ( n % 3 ) # \"10\" (Base 2 1000 % decimal 3 == base 2 10)","title":"Modulo"},{"location":"number/#multiplication","text":"Multiplying a float, integer, string or Number by a Number (or vice versa) will return a new Number with the multiplied value, even if the bases are different: from rebelbase import Base2 , Base3 n = Base2 ( 8 ) print ( n * Base2 ( 3 )) # \"11000\" (Base 2 1000 * base 2 11 == base 2 11000) print ( n * Base3 ( \"10\" )) # \"11000\" (Base 2 1000 * base 3 10 == base 2 11000) print ( n * \"11\" ) # \"11000\" (Base 2 1000 * base 2 11 == base 2 11000) print ( n * 3 ) # \"11000\" (Base 2 1000 * decimal 3 == base 2 11000)","title":"Multiplication"},{"location":"number/#subtraction","text":"Subtracting a float, integer, string or Number from a Number (or vice versa) will return a new Number with subtracted value, even if the bases are different: from rebelbase import Base2 , Base3 a = Base2 ( 17 ) print ( a - Base2 ( 3 )) # \"1110\" (Base 2 10001 - base 2 11 == base 2 1110) print ( a - Base3 ( \"10\" )) # \"1110\" (Base 2 10001 - base 3 10 == base 2 1110) print ( a - \"11\" ) # \"1110\" (Base 2 10001 - base 2 11 == base 2 1110) print ( a - 3 ) # \"1110\" (Base 2 10001 - decimal 3 == base 2 1110)","title":"Subtraction"},{"location":"optional-zero/","text":"Optional zero support A Number doesn't have to support zero values. But why would you not want to? Why? Spreadsheets, for example, have two axes: Integer y axes that run from 1 to infinity String x axes that run from A to Z , then AA to ZZ , then AAA to ZZZ , and so on to infinity At first glance, that x axis might feel like a base 26 number with digits A =0, B =1, through to Z =25: Decimal: | 0 | 1 | 2 | 3 | 4 | ... | 23 | 24 | 25 Digits: | A | B | C | D | E | ... | X | Y | Z ...but consider the consequences of that approach: x axes would start at decimal 0, which is inconsistent with y axes starting at decimal 1. If Z represented decimal value 25 then we'd want AA to represent decimal value 25 + 1 -- but decimal 26 would actually be BA : Powers: | 26^1 | 26^0 | Value: | 1x26 | 0x1 | = 26 Digits: | B | A | = BA The solution is to create a base 26 system without zero. The digits and their decimal values look like this: Decimal: | 1 | 2 | 3 | 4 | 5 | ... | 24 | 25 | 26 Digits: | A | B | C | D | E | ... | X | Y | Z In this system, when we're forced to work without zero, Z represents decimal 26 and AA correctly represents decimal 26+1: Powers: | 26^1 | 26^0 | Value: | 1x26 | 1x1 | = 27 Digits: | A | A | = AA Implementation To create a Number without zero, see the Number class / \"Numeric bases without zero\" .","title":"Optional zero support"},{"location":"optional-zero/#optional-zero-support","text":"A Number doesn't have to support zero values. But why would you not want to?","title":"Optional zero support"},{"location":"optional-zero/#why","text":"Spreadsheets, for example, have two axes: Integer y axes that run from 1 to infinity String x axes that run from A to Z , then AA to ZZ , then AAA to ZZZ , and so on to infinity At first glance, that x axis might feel like a base 26 number with digits A =0, B =1, through to Z =25: Decimal: | 0 | 1 | 2 | 3 | 4 | ... | 23 | 24 | 25 Digits: | A | B | C | D | E | ... | X | Y | Z ...but consider the consequences of that approach: x axes would start at decimal 0, which is inconsistent with y axes starting at decimal 1. If Z represented decimal value 25 then we'd want AA to represent decimal value 25 + 1 -- but decimal 26 would actually be BA : Powers: | 26^1 | 26^0 | Value: | 1x26 | 0x1 | = 26 Digits: | B | A | = BA The solution is to create a base 26 system without zero. The digits and their decimal values look like this: Decimal: | 1 | 2 | 3 | 4 | 5 | ... | 24 | 25 | 26 Digits: | A | B | C | D | E | ... | X | Y | Z In this system, when we're forced to work without zero, Z represents decimal 26 and AA correctly represents decimal 26+1: Powers: | 26^1 | 26^0 | Value: | 1x26 | 1x1 | = 27 Digits: | A | A | = AA","title":"Why?"},{"location":"optional-zero/#implementation","text":"To create a Number without zero, see the Number class / \"Numeric bases without zero\" .","title":"Implementation"}]}